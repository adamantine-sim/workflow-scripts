import autofoam
import autofoam.mesh
import autofoam.cases
import json
import os
import argparse
import sys

def nested_get(dict, keys):
    ''' modifies a nested dictionary value given a list of keys to the nested location'''
    for key in keys[:-1]:
        dict = dict.setdefault(key, {})
    return dict[keys[-1]]


def nested_set(dict, keys, value):
    ''' modifies a nested dictionary value given a list of keys to the nested location'''
    for key in keys[:-1]:
        dict = dict.setdefault(key, {})
    dict[keys[-1]] = value


def generate_cases(inputs):

    # Rescale and clean the STL
    working_stl_path = autofoam.mesh.preprocess_stl(inputs)
    
    # Generate OpenFOAM mesh and extract stl features
    origin, bbDict = autofoam.mesh.create_background_mesh(inputs, working_stl_path)
    autofoam.mesh.extract_stl_features(inputs, origin)
    
    # Create part mesh for provided STL
    autofoam.mesh.create_part_mesh(inputs, bbDict)
    
    # Create case files
    cases = inputs["cases"]

    for case_name, case_dict in cases.items():
        # assumed case label generated by myna: 'P#_rve_#'
        case_labels = case_name.split("_")

        # convert case name to nested directory structure: /P#/rve_#/
        partNo = ''.join(filter(str.isdigit, case_labels[0]))
        rveNo  = ''.join(filter(str.isdigit, case_labels[2]))

        case_working_dir = os.path.join(
            inputs["case_dir"], f"P{partNo}", f"rve_{rveNo}", "additivefoam")

        autofoam.cases.create_case(inputs, case_name, case_working_dir)

def main():
    ''' Resolve file paths before calling autofoam functions for case creation '''
    # set the working directory where autofoam was called
    working_dir = os.getcwd()

    parser = argparse.ArgumentParser()

    parser.add_argument(
        "-case", dest="case_dir", default=working_dir, help="Case directory")

    parser.add_argument(
        "-dict", dest="file_path", default="autofoam_inputs.json", help="JSON file path")

    args = parser.parse_args()
 
    # Configure the absolute paths
    if os.path.isabs(args.case_dir):
        case_dir = args.case_dir
    else:
        case_dir = os.path.join(working_dir, args.case_dir)
        case_dir = os.path.normpath(case_dir)

    if os.path.isabs(args.file_path):
        file_path = args.file_path
    else:
        file_path = os.path.join(case_dir, args.file_path)
        file_path = os.path.normpath(file_path)

    # Read JSON input file
    try:
        with open(file_path, "r") as f:
            inputs = json.load(f)
    except FileNotFoundError:
        print(f"File not found: {file_path}")
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"Error parsing JSON file: {file_path}")
        sys.exit(1)
    
    # Set the absolute paths for stl_path and template_dir
    ''' these absolute paths are the same for every case '''
    nested_paths = [
        ["mesh","stl_path"],
        ["template","template_dir"]]
    
    for nested_path in nested_paths:
        path = nested_get(inputs, nested_path)
        if not os.path.isabs(path):
            absolute_path = os.path.join(case_dir, path)
            absolute_path = os.path.normpath(absolute_path)
            nested_set(inputs, nested_path, absolute_path)
    
    # Set the absolute path for the scan path file
    ''' these absolute paths are different for every case '''
    for case in inputs["cases"].keys():
        nested_path = ["cases", case, "scan_path"]
        path = nested_get(inputs, nested_path)
        if not os.path.isabs(path):
            absolute_path = os.path.join(case_dir, path)
            absolute_path = os.path.normpath(absolute_path)
            nested_set(inputs, nested_path, absolute_path)

    # the structure of the case.py function relies on this variable being set
    inputs["case_dir"] = case_dir

    # Generate the AdditiveFOAM input directory for each case
    generate_cases(inputs)
