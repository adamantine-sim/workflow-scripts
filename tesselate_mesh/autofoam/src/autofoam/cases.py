import os
import re
import subprocess
import string
import math
import autofoam.util
import numpy as np

def path_end_times(filename):
    ''' 
        The scan paths generated by peregrine account for the entire layer
        time of a build. This is expensive to simulate, so we only account
        for the active scan path time here.
    '''

    path = [[0]*6]
    with open(filename, 'r') as f:
        for line in f.readlines()[1:] :
            entry = [float(x) for x in line.strip().split()]
            if (len(entry) == 6) : path.append(entry)

    times = [0]
    for i in range(1, len(path)) :
        if path[i][0] == 1 :
            times.append(times[i-1] + path[i][5])
        else :
            d = [abs(b - a) for a, b in zip(path[i-1][1:4], path[i][1:4])]
            dist = math.sqrt(d[0]*d[0] + d[1]*d[1] + d[2]*d[2])
            times.append(times[i-1] + dist / path[i][5])

    for i, segment in reversed(list(enumerate(path))) :
        if segment[4] > 1e-8 :        
            activeTime = min(times[-1], times[i])
            break

    return activeTime, times[-1]


def slice_mesh(inputs, case, height) :
    ''' slice the part mesh at a specified build height '''
    s = subprocess.check_output(
        f"checkMesh -case {case} -noTopology | grep -i 'Overall domain bounding box'",
        shell=True).decode('utf-8')

    bb_str = re.findall('\(([^)]+)', s)

    bb_min = [float(x) - 1e-8 for x in bb_str[0].split(" ")]
    bb_max = [float(x) + 1e-8 for x in bb_str[1].split(" ")]
    bb = bb_min + bb_max
    bb[-1] = height

    topoSetDict = f"{case}/system/topoSetDict"
    lines = open(topoSetDict, 'r').readlines()

    keys = ["xmin", "ymin", "zmin", "xmax", "ymax", "zmax"]

    for k, key in enumerate(keys) :
        for i, line in enumerate(lines) : 
            if line.startswith(key) :
                token = line.replace(";","").split()[-1]
                lines[i] = line.replace(token, str(bb[k]))

    with open(topoSetDict, 'w') as f : 
        for line in lines :
            f.write(str(line))

    # remove the created cellSet and renumber new mesh
    os.system(f"topoSet -case {case}")
    os.system(f"subsetMesh -case {case} -overwrite c0 -patch part")
    os.system(f"rm -rf {case}/constant/polyMesh/sets")
    os.system(f"rm -rf {case}/constant/polyMesh/*Level")
    os.system(f"renumberMesh -case {case} -overwrite")

    # align the sliced mesh with the top at z=0 plane
    s = subprocess.check_output(
        f'checkMesh -case {case} -noTopology | grep -i "Overall domain bounding box"',
        shell=True).decode('utf-8')

    zmax = float(re.findall('\(([^)]+)', s)[-1].split(" ")[-1])
    translation = " ".join(list(map(str, [0, 0, -zmax])))
    os.system(f'transformPoints -case {case} "translate=({translation})"')

    # refine the mesh within the layer
    layer_thickness = min(inputs["mesh"]["layer_thickness"], zmax)
    bb = [[bb[0], bb[1], -layer_thickness],[bb[3], bb[4], 0.0]]
    refine_mesh_in_layer(case, bb)

def refine_mesh_in_RVE(case, bb):
    os.system(
        f'foamDictionary -entry box -set '
        f'"( {bb[0][0]} {bb[0][1]} {bb[0][2]} ) '
        f'( {bb[1][0]} {bb[1][1]} {bb[1][2]} )" '
        f'{case}/constant/foamToExaCADict')

    os.system(
        f'foamDictionary -entry geometry/refinementBox/min '
        f'-set "( {bb[0][0]} {bb[0][1]} {bb[0][2]} )" '
        f'{case}/system/refineMeshDict')

    os.system(
        f'foamDictionary -entry geometry/refinementBox/max '
        f'-set "( {bb[1][0]} {bb[1][1]} {bb[1][2]} )" '
        f'{case}/system/refineMeshDict')

    center = [
        0.5*(bb[0][0] + bb[1][0]),
        0.5*(bb[0][1] + bb[1][1]),
        0.5*(bb[0][2] + bb[1][2])]
    
    os.system(
        f'foamDictionary -entry castellatedMeshControls/locationInMesh '
        f'-set "( {center[0]} {center[1]} {center[2]} )" '
        f'{case}/system/refineMeshDict')
    
    os.system(
        f'snappyHexMesh -case {case} -dict system/refineMeshDict -overwrite')


def refine_mesh_in_layer(case, bb):

    os.system(
        f'foamDictionary -entry geometry/refinementBox/min '
        f'-set "( {bb[0][0]} {bb[0][1]} {bb[0][2]} )" '
        f'{case}/system/refineLayerDict')

    os.system(
        f'foamDictionary -entry geometry/refinementBox/max '
        f'-set "( {bb[1][0]} {bb[1][1]} {bb[1][2]} )" '
        f'{case}/system/refineLayerDict')

    center = [
        0.5*(bb[0][0] + bb[1][0]),
        0.5*(bb[0][1] + bb[1][1]),
        0.5*(bb[0][2] + bb[1][2])]
    
    os.system(
        f'foamDictionary -entry castellatedMeshControls/locationInMesh '
        f'-set "( {center[0]} {center[1]} {center[2]} )" '
        f'{case}/system/refineLayerDict')
    
    os.system(
        f'snappyHexMesh -case {case} -dict system/refineLayerDict -overwrite')

#def create_case(inputs, simulate_inactive_path_time=False, peregrine_scanfile=True):
def create_case(inputs, case_name, case_working_dir):
    ''' create case files for AdditiveFOAM based on user inputs'''

    case_dict = inputs["cases"][case_name]

    scan_path_dir = os.path.abspath(case_dict["scan_path"])

    template_dir = os.path.abspath(inputs["template"]["template_dir"])

    # Extract the laser power and spot size from the part.npz file
    # (note: spot size is actually given in um and not mm, may have been fixed in Peregrine)
    part_data_file = os.path.join(scan_path_dir, "part.npz")
    data = np.load(part_data_file, allow_pickle=True)
    power_index = np.where(data["parameter_names"] == "Power (W)")[0][0]
    power = data['parameter_values'][power_index]
    spot_size_index = np.where(data["parameter_names"] == "Spot Size (mm)")[0][0]
    spot_size = 0.5 * data['parameter_values'][spot_size_index] * 1e-6 # convert to radius in meters 

    # Assign a scan path file to each layer
    layers = range(case_dict["layers"][0], case_dict["layers"][-1] + 1) 
    filenames = next(os.walk(scan_path_dir), (None, None, []))[2]

    # Remove "part.npz" from filenames in provided scan path directory
    filenames = [filename for filename in filenames if not os.path.basename(filename).startswith("part.")]

    scan_path_files = []
    for layer in layers:
        found_file = False
        for f in filenames:
            layer_id = int(f.strip(string.ascii_letters).replace(".","").lstrip("0"))
            if layer == layer_id:
                scan_path_files.append(os.path.join(scan_path_dir, f))
                found_file = True
                break
        if not found_file:
            raise ValueError(f"No file found for layer {layer}")

    # calculate the layer thickness from the provided layer heights
    heights = case_dict["heights"]
    if len(layers) == 1:
        thickness = 0
    else:
        thickness = abs(heights[-1] - heights[0]) / max(len(layers) - 1, 1)
    
    # create an empty directory: 'P#/rve_#/additivefoam'
    if os.path.exists(case_working_dir):
        os.system(f"rm -rf {case_working_dir}")

    os.system(f"mkdir -p {case_working_dir}")

    # create sub-directory for each layer: 'P#/rve_#/additivefoam/#'
    for i, layer in enumerate(layers) :

        layer_dir = os.path.join(case_working_dir, f"{layer}")

        os.system(f"foamCloneCase {template_dir} {layer_dir}")
        
        # convert the scan path file extracted from peregrine
        path_name = os.path.basename(scan_path_files[i])
        new_scan_path_file = os.path.join(layer_dir, "constant", path_name)

        autofoam.util.convert_peregrine_scanpath(
            scan_path_files[i],
            new_scan_path_file,
            power)

        # Set the beam size
        # 1. Get heatSourceModel
        heat_source_model = subprocess.check_output(
            f'foamDictionary -entry beam/heatSourceModel -value '
            + f'{layer_dir}/constant/heatSourceDict',
            shell=True).decode('utf-8').strip()
        # 2. Get heatSourceModelCoeffs/dimensions
        heat_source_dimensions = subprocess.check_output(
            f'foamDictionary -entry beam/{heat_source_model}Coeffs/dimensions -value '
            + f'{layer_dir}/constant/heatSourceDict',
            shell=True).decode('utf-8').strip()
        heat_source_dimensions = heat_source_dimensions.replace("(", "").replace(")", "").strip()
        heat_source_dimensions = [float(x) for x in heat_source_dimensions.split(" ")]
        # 3. Modify X- and Y-dimensions
        heat_source_dimensions[:2] = [spot_size, spot_size]
        heat_source_dimensions = [round(dim, 7) for dim in heat_source_dimensions]
        # 4. Write to file
        heat_source_dim_string = str(heat_source_dimensions).replace("[","( ").replace("]", " )").replace(",","")
        os.system(
            f'foamDictionary -entry beam/{heat_source_model}Coeffs/dimensions -set "{heat_source_dim_string}" '
            + f"{layer_dir}/constant/heatSourceDict")

        # set the end time of the simulation
        active_time, total_time = path_end_times(new_scan_path_file)
        end_time = active_time

        os.system(
            f"foamDictionary -entry endTime -set {end_time} "
            + f"{layer_dir}/system/controlDict")

        os.system(
            f'foamDictionary -entry beam/pathName -set'
            + f''' '"{path_name}"' '''
            + f"{layer_dir}/constant/heatSourceDict")
        
        slice_mesh(inputs, layer_dir, heights[0] + i*thickness)

        refine_mesh_in_RVE(layer_dir, case_dict["RVE"])
#------------------------------------------------------------------------------#
